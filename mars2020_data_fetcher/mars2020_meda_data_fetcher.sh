#!/bin/bash

# Author: Raul Jesus Lopez @la9una
# Repository: https://github.com/la9una/mars_habitability
# 
# Script Title: Perseverance Rover MEDA Data Fetcher
# Description: This script retrieves and lists datasets generated by MEDA, the weather station 
# onboard the Perseverance rover, from various data directories. The objective is to find and list 
# all .csv files available for a selected data type and filter them based on selected sensor types.

# Base URLs for each data type
declare -A BASE_URLS=(
    ["ESD"]="https://atmos.nmsu.edu/PDS/data/PDS4/Mars2020/mars2020_meda/data_raw_env/"
    ["PAR"]="https://atmos.nmsu.edu/PDS/data/PDS4/Mars2020/mars2020_meda/data_partially_processed_env/"
    ["CAL"]="https://atmos.nmsu.edu/PDS/data/PDS4/Mars2020/mars2020_meda/data_calibrated_env/"
    ["DER"]="https://atmos.nmsu.edu/PDS/data/PDS4/Mars2020/mars2020_meda/data_derived_env/"
)

# Function to display the script introduction
display_intro() {
    echo -e "\033[1;32m
    #################################################################
    #                                                               #
    #  Perseverance Rover MEDA Data Fetcher                         #
    #  Author: Raul Jesus Lopez @la9una                             #
    #  Repository: https://github.com/la9una/mars_habitability      #
    #                                                               #
    #################################################################
    #                                                               #
    #  Description: This script retrieves and lists                 #
    #  datasets generated by MEDA, the weather                      #
    #  station onboard the Perseverance rover, from                 #
    #  various data directories. The objective is                   #
    #  to find and list all .csv files available                    #
    #  for a selected data type and filter them                     #
    #  based on selected sensor types.                              #
    #                                                               #
    #################################################################
    \033[0m"
}

# Function to display a progress indicator
progress_indicator() {
    local task_name="$1"
    echo -n "$task_name"
    while :; do
        echo -n "."
        sleep 1
    done
}

# Function to print a stylized message
print_message() {
    local message="$1"
    echo -e "\n\033[1;34m>> $message\033[0m\n"
}

# Function to recursively explore directories and fetch .csv files
fetch_files() {
    local url="$1"
    wget -q -O- "$url" | grep -Eo 'href="[^"]+"' | sed 's/href="//;s/"//' | while read -r line; do
        # If it's a directory, call the function recursively
        if [[ "$line" == */ ]]; then
            fetch_files "${url}${line}"
        elif [[ "$line" =~ \.CSV$ ]]; then
            # Add the full URL of the CSV file to the temporary file
            echo "${url}${line}" >> "$FILE_LIST"
        fi
    done
}

# Function to parse and expand sol ranges
parse_sols() {
    local sol_input=("$@")
    local sols=()

    for item in "${sol_input[@]}"; do
        if [[ "$item" =~ ^[0-9]+$ ]]; then
            sols+=("$item")
        elif [[ "$item" =~ ^([0-9]+)-([0-9]+)$ ]]; then
            start=${BASH_REMATCH[1]}
            end=${BASH_REMATCH[2]}
            for ((i = start; i <= end; i++)); do
                sols+=("$i")
            done
        else
            echo -e "\033[1;31mInvalid sol input: $item. Exiting.\033[0m"
            exit 1
        fi
    done

    echo "${sols[@]}"
}

# Function to filter files based on sensor types and sol numbers
filter_files() {
    local sensors=("${selected_sensors[@]}")
    local sols=("${selected_sols[@]}")

    > "filtered_file_list.txt" # Clear the file before filtering
    for sensor_type in "${sensors[@]}"; do
        for sol in "${sols[@]}"; do
            sol_formatted=$(printf "%04d" "$sol") # Format sol as 4 digits
            grep -E "/WE__${sol_formatted}___________${selected_data_type}_${sensor_type}_" "$FILE_LIST" >> "filtered_file_list.txt"
        done
    done
    sort -u "filtered_file_list.txt" -o "filtered_file_list.txt" # Remove duplicates if any
}

# Function to download files into the appropriate directory with progress and single overwrite confirmation
download_files() {
    # Create the download directory based on the data type
    local download_dir="MEDA_${selected_data_type}_DATA"
    mkdir -p "$download_dir" # Create the directory if it doesn't exist

    # Ask the user if they want to overwrite existing files (one-time prompt)
    local overwrite_all="n"
    read -p "Do you want to overwrite existing files if they exist? (y/n): " overwrite_all
    if [[ "$overwrite_all" != "y" && "$overwrite_all" != "n" ]]; then
        echo "Invalid response. Defaulting to 'n' (no)."
        overwrite_all="n"
    fi

    while read -r file_url; do
        # Extract the filename from the URL
        local filename=$(basename "$file_url")
        local filepath="$download_dir/$filename"
        
        # Check if the file already exists and handle based on user response
        if [[ -e "$filepath" && "$overwrite_all" == "n" ]]; then
            echo -e "\033[1;33mSkipping $filename (already exists)...\033[0m"
        else
            # Download the file with progress
            wget --show-progress "$file_url" -O "$filepath"
        fi
    done < "filtered_file_list.txt"
}

# Display the script introduction
display_intro

# Display a menu for the user to select the data type
print_message "Select the type of data:"
data_types=("ESD (Raw Data)" "PAR (Partially Processed Data)" "CAL (Calibrated Data)" "DER (Derived Data)")
data_type_codes=("ESD" "PAR" "CAL" "DER")

for i in "${!data_types[@]}"; do
    echo "$((i + 1)). ${data_types[$i]}"
done

read -p "Enter the number corresponding to the type of data you want to index: " data_type_index

# Validate selection
if [[ $data_type_index -lt 1 || $data_type_index -gt ${#data_types[@]} ]]; then
    echo -e "\033[1;31mInvalid selection. Exiting.\033[0m"
    exit 1
fi

selected_data_type="${data_type_codes[$((data_type_index - 1))]}"
selected_url="${BASE_URLS[$selected_data_type]}"

# Set the file name dynamically based on the selected data type
FILE_LIST="data_${selected_data_type}_file_list.txt"

# Check if the file list exists and is not empty
if [[ -e "$FILE_LIST" && -s "$FILE_LIST" ]]; then
    read -p "A list of resources already exists. Do you want to continue indexing resources? (y/n): " answer
    if [[ "$answer" != "y" ]]; then
        echo -e "\033[1;33mSkipping indexing step.\033[0m"
    else
        > "$FILE_LIST" # Clear the file if user wants to re-index
        print_message "Indexing $selected_data_type data. This may take a while..."
        progress_indicator "Fetching files" &
        PROGRESS_PID=$!

        fetch_files "$selected_url"

        # Stop the progress indicator
        kill $PROGRESS_PID
        wait $PROGRESS_PID 2>/dev/null
        echo " [COMPLETED]"
    fi
else
    print_message "Indexing $selected_data_type data. This may take a while..."
    progress_indicator "Fetching files" &
    PROGRESS_PID=$!

    fetch_files "$selected_url"

    # Stop the progress indicator
    kill $PROGRESS_PID
    wait $PROGRESS_PID 2>/dev/null
    echo " [COMPLETED]"
fi

# Check if any files were found
if [ ! -s "$FILE_LIST" ]; then
    print_message "No .csv files were found in the selected directory."
    exit 0
else
    print_message "Files have been indexed. Now, select the sensors to filter."
fi

# Prompt user for sensor types (multiple selection allowed)
print_message "Select the type(s) of sensor (separated by space):"
sensor_types=("WS (Wind Sensor)" "ATS (Air Temperature Sensor)" "TIRS (Thermal Infra-Red Sensor)" "HS (Relative Humidity Sensor)" "RDS (Radiation and Dust Sensor)" "PS (Pressure Sensor)")
sensor_type_codes=("WS" "ATS" "TIRS" "HS" "RDS" "PS")

for i in "${!sensor_types[@]}"; do
    echo "$((i + 1)). ${sensor_types[$i]}"
done

read -p "Enter the numbers corresponding to the sensor(s) you want to filter (separated by space): " -a sensor_type_indices

# Validate selections and collect selected sensors
selected_sensors=()
for index in "${sensor_type_indices[@]}"; do
    if [[ $index -ge 1 && $index -le ${#sensor_types[@]} ]]; then
        selected_sensors+=("${sensor_type_codes[$((index - 1))]}")
    else
        echo -e "\033[1;31mInvalid selection: $index. Exiting.\033[0m"
        exit 1
    fi
done

# Prompt user for sol numbers or ranges
print_message "Enter the sol numbers or ranges (e.g., 2, 10-12, 15):"
read -p "Enter sol numbers/ranges: " -a sol_input

# Parse sol numbers/ranges
selected_sols=($(parse_sols "${sol_input[@]}"))

# Apply the filtering based on user selection
print_message "Filtering files for sensors: ${selected_sensors[*]} and sols: ${selected_sols[*]}"
filter_files "${selected_sensors[@]}" "${selected_sols[@]}"

# Check if any files matched the criteria
if [ ! -s "filtered_file_list.txt" ]; then
    print_message "No files matched the selected sensor and sol criteria."
    exit 0
else
    print_message "Files matching the criteria have been listed in filtered_file_list.txt."
fi

# Prompt user if they want to download the files
read -p "Do you want to download the filtered files? (y/n): " download_answer
if [[ "$download_answer" == "y" ]]; then
    print_message "Downloading files..."
    download_files
    print_message "Files have been downloaded to the ${selected_data_type}_Datasets directory."
else
    echo -e "\033[1;33mDownload step skipped.\033[0m"
fi
